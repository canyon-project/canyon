window["packages/canyon-platform/src/components/CanyonReport/helper.tsx"] = {"content":"export function coreFn(\n  fileCoverage: any,\n  fileDetail: string,\n): {\n  times: {\n    lineNumber: number;\n    count: number;\n  }[];\n  rows: string[];\n  maxWidth: number;\n  lines: {\n    executionNumber: number;\n  }[];\n} {\n  const nullData = {\n    times: [],\n    rows: [],\n    maxWidth: 0,\n    lines: [],\n  };\n  if (!fileCoverage.s) {\n    return nullData;\n  }\n\n  const content = fileDetail;\n  // 1.转换成数组\n  const rows = [\"\"];\n  let index = 0;\n  for (let i = 0; i < content.length; i++) {\n    if (content[i] === \"\\n\") {\n      index += 1;\n      rows.push(\"\");\n    } else {\n      rows[index] += content[i];\n    }\n  }\n  const maxWidth = JSON.parse(JSON.stringify(rows)).sort(\n    (a: string, b: string) => -(a.length - b.length),\n  )[0].length;\n\n  // 获取numberOfRows\n  // 获取行覆盖率\n  function getLineCoverage(data: any) {\n    const statementMap = data.statementMap;\n    const statements = data.s;\n    const lineMap = Object.create(null);\n    Object.entries(statements).forEach(([st, count]: any) => {\n      if (!statementMap[st]) {\n        return;\n      }\n      const { line } = statementMap[st].start;\n      const prevVal = lineMap[line];\n      if (prevVal === undefined || prevVal < count) {\n        lineMap[line] = count;\n      }\n    });\n    return lineMap;\n  }\n\n  // 计算行\n  const lineStats = getLineCoverage(fileCoverage);\n  if (!lineStats) {\n    return nullData;\n  }\n  // numberOfRows\n  const numberOfRows: any[] = [];\n  Object.entries(lineStats).forEach(([lineNumber, count]) => {\n    numberOfRows.push({ lineNumber, count });\n    // 这边计算出了行的次数！！！！！！\n  });\n\n  const lines = [];\n  for (let i = 0; i < rows.length; i++) {\n    if (numberOfRows.find((n) => Number(n.lineNumber) === i + 1)) {\n      lines.push({\n        executionNumber: numberOfRows.find(\n          (n) => Number(n.lineNumber) === i + 1,\n        ).count,\n      });\n    } else {\n      lines.push({\n        executionNumber: -1,\n      });\n    }\n  }\n  return {\n    times: numberOfRows,\n    rows,\n    lines,\n    maxWidth,\n  };\n}\n\nexport function genDecorationsLv2Array(code, startends) {\n  const lines = code.split(\"\\n\");\n  function convertRanges(arr) {\n    const result = [];\n    arr.forEach((data) => {\n      const start = data.start;\n      const end = data.end;\n\n      for (let i = start[0]; i <= end[0]; i++) {\n        const intervalStart = i === start[0] ? start[1] : 0;\n        const intervalEnd = lines[i].length;\n        result.push([i, intervalStart, intervalEnd]);\n      }\n    });\n    // 输出每一行的区间值\n    return result;\n  }\n\n  const convertedData = convertRanges(startends);\n  function mergeRanges(ranges) {\n    // 对区间按照起始位置进行排序\n    ranges.sort((a, b) => a[0] - b[0]);\n\n    const merged = [];\n\n    let currentRange = ranges[0];\n    for (let i = 1; i < ranges.length; i++) {\n      const nextRange = ranges[i];\n\n      // 如果当前区间和下一个区间有重叠，则合并它们\n      if (currentRange[1] >= nextRange[0]) {\n        currentRange[1] = Math.max(currentRange[1], nextRange[1]);\n      } else {\n        merged.push(currentRange);\n        currentRange = nextRange;\n      }\n    }\n\n    merged.push(currentRange);\n\n    return merged;\n  }\n\n  function mergeRows(array) {\n    const groupedRows = {};\n\n    // 将相同行的元素分组\n    array.forEach(([row, col, value]) => {\n      if (!groupedRows[row]) {\n        groupedRows[row] = [];\n      }\n      groupedRows[row].push([col, value]);\n    });\n\n    const mergedArray = [];\n\n    // 对每个分组合并区间\n    for (const row in groupedRows) {\n      const mergedRanges = mergeRanges(groupedRows[row]);\n      mergedRanges.forEach((range) => {\n        mergedArray.push([parseInt(row), range[0], range[1]]);\n      });\n    }\n\n    return mergedArray;\n  }\n\n  const mergedArray = mergeRows(convertedData);\n  return mergedArray;\n}\n\nexport function capitalizeFirstLetter(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\n\nexport function checkSuffix(path) {\n  //   只要path里含有vue、js、jsx等就返回true\n  return (\n    path.includes(\".vue\") ||\n    path.includes(\".js\") ||\n    path.includes(\".jsx\") ||\n    path.includes(\".ts\") ||\n    path.includes(\".tsx\")\n  );\n}\n\nexport function mergeIntervals(intervals) {\n  // 如果输入为空，直接返回空列表\n  if (intervals.length === 0) {\n    return [];\n  }\n\n  // 将所有线段按起始位置进行排序\n  intervals.sort((a, b) => a[0] - b[0]);\n\n  // 初始化结果列表\n  const merged = [];\n  let [currentStart, currentEnd] = intervals[0];\n\n  for (const [start, end] of intervals.slice(1)) {\n    if (start <= currentEnd) {\n      // 当前线段与前一个线段有重叠\n      currentEnd = Math.max(currentEnd, end); // 更新结束位置\n    } else {\n      // 当前线段与前一个线段没有重叠\n      merged.push([currentStart, currentEnd]); // 将前一个线段加入结果列表\n      [currentStart, currentEnd] = [start, end]; // 更新当前线段的起始和结束位置\n    }\n  }\n\n  // 添加最后一个线段\n  merged.push([currentStart, currentEnd]);\n\n  return merged;\n}\n","coverage":{"name":"zt"}}