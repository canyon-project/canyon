## hard-merge-go（函数级块哈希合并 Demo）

### 目标

本示例用 Go 语言实现“函数级别”的覆盖率硬合并思路：
- 合并前提：仅在“同路径（同文件名）文件”之间进行块级合并。
- 块定义：以覆盖率 `fnMap[id].loc` 所标注的函数范围作为“代码块”。
- 匹配方式：对每个函数块提取源码片段，做空白无关归一化后计算 SHA1 哈希，哈希相同即视为“相同函数块”。

当前代码是一个最小可运行的演示，用内置的两份 `b.js` 覆盖率 JSON 与源码字符串进行对比与合并，不依赖磁盘文件。

### 合并策略（当前版本）

当基线文件与其它提交文件中存在“相同哈希”的函数时：
- 取“其它提交”中该哈希下函数计数的最大值 `maxOther`；
- 将 `maxOther` 累加到“基线文件”中所有同哈希函数的计数上。

这样可以避免简单求和导致“重复出现的相同函数”计数被成倍放大，但仍有一定放大风险（见“局限”）。

程序同时会打印每个函数块“截取到的源码片段”，方便人工核对匹配是否合理。

### 代码入口

文件：`playground/hard-merge-go/main.go`

关键函数：
- `buildFnHashToIds(entry, content)`：根据 `fnMap.loc` 截取函数源码、归一化并计算哈希，构建 `哈希 → 函数 ID 列表` 索引；同时打印每个函数的源码片段。
- `mergeFunctionsByHash(base, baseContent, other, otherContent)`：按“相同哈希”从 `other` 取最大计数，累加到 `base` 的所有同哈希函数计数。

### 运行

由于该示例内置了样例数据，直接运行即可：

```bash
cd playground/hard-merge-go
go run .
```

运行后会看到：
- 每个函数块的截取源码片段；
- 合并完成后的“基线函数计数”预览。

若遇到 Go Module 相关报错，可切换到 GOPATH 模式或临时创建 `go.mod` 再运行；本示例本身不依赖外部第三方库。

### 局限与改进方向

- 局限：
  - 当“同文件内存在多个完全相同源码的函数”时，当前策略对基线中所有同哈希函数都累加了 `maxOther`，仍可能存在计数偏大。
  - 暂未支持 statements/branches 的块级匹配与合并，仅函数级演示。

### 与 JS 版本的关系

`playground/hard-merge/scripts/hard-merge.js` 实现了文件级的硬合并（完全相同文件才合并）。本 Go 示例展示了如何把维度降到“函数级别”的块匹配与计数合并，为后续更精细的块级合并提供参考实现。


